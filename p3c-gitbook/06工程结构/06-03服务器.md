## (三) 服务器

1. 【强制】调用远程操作必须有超时设置。
<br><span style="color:orange">说明</span>：类似于 HttpClient 的超时设置需要自己明确去设置 Timeout。根据经验表明，无数次的故障都是因为没有设置
超时时间。
2. 【推荐】客户端设置远程接口方法的具体超时时间（单位 ms），超时设置生效顺序一般为：
   1. 客户端 Special Method；
   2. 客户端接口级别；
   3. 服务端 Special Method；
   4. 服务端接口级别。
3. 【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。
<br><span style="color:orange">说明</span>：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服务器端会因为处于time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。
<br><span style="color:green">正例</span>：在 linux 服务器上请通过变更/etc/sysctl. conf 文件去修改该缺省值（秒）：net. ipv4. tcp_fin_timeout=30
4. 【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）
<br><span style="color:orange">说明</span>：主流操作系统的设计是将 TCP / UDP 连接采用与文件一样的方式去管理，即一个连接对应于一个 fd。主流的 linux服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。建议将 linux 服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。
5. 【推荐】给 JVM 环境参数设置-XX：+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。同時輸出gc操作到日志文件。
<br><span style="color:orange">说明</span>：OOM 的发生是有概率的，甚至相隔数月才出现一例，出错时的堆内信息对解决问题非常有帮助。gc日志则用于分析gc情况并进行后续gc优化。示例：
```
    java -XX:+UseG1GC -Xms1G -Xmx1G 
    -XX:+HeapDumpOnOutOfMemoryError 
    -XX:HeapDumpPath=/var/log/dump 
    -XX:+PrintGCDetails 
    -Xloggc:/var/log/gc.log 
    -XX:+UseGCLogFileRotation 
    -XX:GCLogFileSize=512k 
    -XX:+PrintGCDateStamps 
    -jar app.jar
```
6. 【推荐】在线上生产环境，JVM 的 Xms 和 Xmx 设置一样大小的内存容量，避免在 GC 后调整堆大小带来的压力。
7. 【推荐】了解每个服务大致的平均耗时，可以通过独立配置线程池，将较慢的服务与主线程池隔离开，免得不同服务的线程同归于尽。
8. 【参考】服务器内部重定向必须使用 forward；外部部重定向地址必须使用 URL Broker 生成，否则因线上采用 HTTPS 协议而导致浏览器提示“不安全”。此外，还会带来 URL 维护不一致的问题。